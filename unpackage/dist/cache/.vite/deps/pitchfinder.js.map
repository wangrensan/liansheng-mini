{
  "version": 3,
  "sources": ["../../../../../node_modules/pitchfinder/lib/detectors/yin.js", "../../../../../node_modules/pitchfinder/lib/detectors/amdf.js", "../../../../../node_modules/pitchfinder/lib/detectors/acf2plus.js", "../../../../../node_modules/pitchfinder/lib/detectors/dynamic_wavelet.js", "../../../../../node_modules/pitchfinder/lib/detectors/macleod.js", "../../../../../node_modules/pitchfinder/lib/tools/frequencies.js", "../../../../../node_modules/pitchfinder/lib/index.js"],
  "sourcesContent": ["\"use strict\";\n/*\n  Copyright (C) 2003-2009 Paul Brossier <piem@aubio.org>\n  This file is part of aubio.\n  aubio is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n  aubio is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n  You should have received a copy of the GNU General Public License\n  along with aubio.  If not, see <http://www.gnu.org/licenses/>.\n*/\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DEFAULT_YIN_PARAMS = {\n    threshold: 0.1,\n    sampleRate: 44100,\n    probabilityThreshold: 0.1,\n};\nfunction YIN(params) {\n    if (params === void 0) { params = {}; }\n    var config = __assign(__assign({}, DEFAULT_YIN_PARAMS), params);\n    var threshold = config.threshold, sampleRate = config.sampleRate, probabilityThreshold = config.probabilityThreshold;\n    return function YINDetector(float32AudioBuffer) {\n        // Set buffer size to the highest power of two below the provided buffer's length.\n        var bufferSize;\n        for (bufferSize = 1; bufferSize < float32AudioBuffer.length; bufferSize *= 2)\n            ;\n        bufferSize /= 2;\n        // Set up the yinBuffer as described in step one of the YIN paper.\n        var yinBufferLength = bufferSize / 2;\n        var yinBuffer = new Float32Array(yinBufferLength);\n        var probability = 0, tau;\n        // Compute the difference function as described in step 2 of the YIN paper.\n        for (var t = 0; t < yinBufferLength; t++) {\n            yinBuffer[t] = 0;\n        }\n        for (var t = 1; t < yinBufferLength; t++) {\n            for (var i = 0; i < yinBufferLength; i++) {\n                var delta = float32AudioBuffer[i] - float32AudioBuffer[i + t];\n                yinBuffer[t] += delta * delta;\n            }\n        }\n        // Compute the cumulative mean normalized difference as described in step 3 of the paper.\n        yinBuffer[0] = 1;\n        yinBuffer[1] = 1;\n        var runningSum = 0;\n        for (var t = 1; t < yinBufferLength; t++) {\n            runningSum += yinBuffer[t];\n            yinBuffer[t] *= t / runningSum;\n        }\n        // Compute the absolute threshold as described in step 4 of the paper.\n        // Since the first two positions in the array are 1,\n        // we can start at the third position.\n        for (tau = 2; tau < yinBufferLength; tau++) {\n            if (yinBuffer[tau] < threshold) {\n                while (tau + 1 < yinBufferLength && yinBuffer[tau + 1] < yinBuffer[tau]) {\n                    tau++;\n                }\n                // found tau, exit loop and return\n                // store the probability\n                // From the YIN paper: The threshold determines the list of\n                // candidates admitted to the set, and can be interpreted as the\n                // proportion of aperiodic power tolerated\n                // within a periodic signal.\n                //\n                // Since we want the periodicity and and not aperiodicity:\n                // periodicity = 1 - aperiodicity\n                probability = 1 - yinBuffer[tau];\n                break;\n            }\n        }\n        // if no pitch found, return null.\n        if (tau === yinBufferLength || yinBuffer[tau] >= threshold) {\n            return null;\n        }\n        // If probability too low, return -1.\n        if (probability < probabilityThreshold) {\n            return null;\n        }\n        /**\n         * Implements step 5 of the AUBIO_YIN paper. It refines the estimated tau\n         * value using parabolic interpolation. This is needed to detect higher\n         * frequencies more precisely. See http://fizyka.umk.pl/nrbook/c10-2.pdf and\n         * for more background\n         * http://fedc.wiwi.hu-berlin.de/xplore/tutorials/xegbohtmlnode62.html\n         */\n        var betterTau, x0, x2;\n        if (tau < 1) {\n            x0 = tau;\n        }\n        else {\n            x0 = tau - 1;\n        }\n        if (tau + 1 < yinBufferLength) {\n            x2 = tau + 1;\n        }\n        else {\n            x2 = tau;\n        }\n        if (x0 === tau) {\n            if (yinBuffer[tau] <= yinBuffer[x2]) {\n                betterTau = tau;\n            }\n            else {\n                betterTau = x2;\n            }\n        }\n        else if (x2 === tau) {\n            if (yinBuffer[tau] <= yinBuffer[x0]) {\n                betterTau = tau;\n            }\n            else {\n                betterTau = x0;\n            }\n        }\n        else {\n            var s0 = yinBuffer[x0];\n            var s1 = yinBuffer[tau];\n            var s2 = yinBuffer[x2];\n            // fixed AUBIO implementation, thanks to Karl Helgason:\n            // (2.0f * s1 - s2 - s0) was incorrectly multiplied with -1\n            betterTau = tau + (s2 - s0) / (2 * (2 * s1 - s2 - s0));\n        }\n        return sampleRate / betterTau;\n    };\n}\nexports.YIN = YIN;\n", "\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DEFAULT_AMDF_PARAMS = {\n    sampleRate: 44100,\n    minFrequency: 82,\n    maxFrequency: 1000,\n    ratio: 5,\n    sensitivity: 0.1,\n};\nfunction AMDF(params) {\n    if (params === void 0) { params = {}; }\n    var config = __assign(__assign({}, DEFAULT_AMDF_PARAMS), params);\n    var sampleRate = config.sampleRate;\n    var minFrequency = config.minFrequency;\n    var maxFrequency = config.maxFrequency;\n    var sensitivity = config.sensitivity;\n    var ratio = config.ratio;\n    var amd = [];\n    /* Round in such a way that both exact minPeriod as\n     exact maxPeriod lie inside the rounded span minPeriod-maxPeriod,\n     thus ensuring that minFrequency and maxFrequency can be found\n     even in edge cases */\n    var maxPeriod = Math.ceil(sampleRate / minFrequency);\n    var minPeriod = Math.floor(sampleRate / maxFrequency);\n    return function AMDFDetector(float32AudioBuffer) {\n        var maxShift = float32AudioBuffer.length;\n        var t = 0;\n        var minval = Infinity;\n        var maxval = -Infinity;\n        var frames1, frames2, calcSub, i, j, u, aux1, aux2;\n        // Find the average magnitude difference for each possible period offset.\n        for (i = 0; i < maxShift; i++) {\n            if (minPeriod <= i && i <= maxPeriod) {\n                for (aux1 = 0, aux2 = i, t = 0, frames1 = [], frames2 = []; aux1 < maxShift - i; t++, aux2++, aux1++) {\n                    frames1[t] = float32AudioBuffer[aux1];\n                    frames2[t] = float32AudioBuffer[aux2];\n                }\n                // Take the difference between these frames.\n                var frameLength = frames1.length;\n                calcSub = [];\n                for (u = 0; u < frameLength; u++) {\n                    calcSub[u] = frames1[u] - frames2[u];\n                }\n                // Sum the differences.\n                var summation = 0;\n                for (u = 0; u < frameLength; u++) {\n                    summation += Math.abs(calcSub[u]);\n                }\n                amd[i] = summation;\n            }\n        }\n        for (j = minPeriod; j < maxPeriod; j++) {\n            if (amd[j] < minval)\n                minval = amd[j];\n            if (amd[j] > maxval)\n                maxval = amd[j];\n        }\n        var cutoff = Math.round(sensitivity * (maxval - minval) + minval);\n        for (j = minPeriod; j <= maxPeriod && amd[j] > cutoff; j++)\n            ;\n        var searchLength = minPeriod / 2;\n        minval = amd[j];\n        var minpos = j;\n        for (i = j - 1; i < j + searchLength && i <= maxPeriod; i++) {\n            if (amd[i] < minval) {\n                minval = amd[i];\n                minpos = i;\n            }\n        }\n        if (Math.round(amd[minpos] * ratio) < maxval) {\n            return sampleRate / minpos;\n        }\n        else {\n            return null;\n        }\n    };\n}\nexports.AMDF = AMDF;\n", "\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DEFAULT_PARAMS = {\n    sampleRate: 44100,\n};\nfunction ACF2PLUS(params) {\n    if (params === void 0) { params = DEFAULT_PARAMS; }\n    var config = __assign(__assign({}, DEFAULT_PARAMS), params);\n    var sampleRate = config.sampleRate;\n    // Implements the ACF2+ algorithm\n    return function ACF2PLUSDetector(float32AudioBuffer) {\n        var maxShift = float32AudioBuffer.length;\n        var rms = 0;\n        var i, j, u, tmp;\n        for (i = 0; i < maxShift; i++) {\n            tmp = float32AudioBuffer[i];\n            rms += tmp * tmp;\n        }\n        rms = Math.sqrt(rms / maxShift);\n        if (rms < 0.01)\n            // not enough signal\n            return -1;\n        /* Trimming cuts the edges of the signal so that it starts and ends near zero.\n         This is used to neutralize an inherent instability of the ACF version I use.*/\n        var aux1 = 0;\n        var aux2 = maxShift - 1;\n        var thres = 0.2;\n        for (i = 0; i < maxShift / 2; i++)\n            if (Math.abs(float32AudioBuffer[i]) < thres) {\n                aux1 = i;\n                break;\n            }\n        for (i = 1; i < maxShift / 2; i++)\n            if (Math.abs(float32AudioBuffer[maxShift - i]) < thres) {\n                aux2 = maxShift - i;\n                break;\n            }\n        var frames = float32AudioBuffer.slice(aux1, aux2);\n        var framesLength = frames.length;\n        var calcSub = new Array(framesLength).fill(0);\n        for (i = 0; i < framesLength; i++)\n            for (j = 0; j < framesLength - i; j++)\n                calcSub[i] = calcSub[i] + frames[j] * frames[j + i];\n        u = 0;\n        while (calcSub[u] > calcSub[u + 1])\n            u++;\n        var maxval = -1, maxpos = -1;\n        for (i = u; i < framesLength; i++) {\n            if (calcSub[i] > maxval) {\n                maxval = calcSub[i];\n                maxpos = i;\n            }\n        }\n        var T0 = maxpos;\n        /* Interpolation is parabolic interpolation. It helps with precision.\n         We suppose that a parabola pass through the three points that comprise the peak.\n         'a' and 'b' are the unknowns from the linear equation system\n         and b/(2a) is the \"error\" in the abscissa.\n         y1,y2,y3 are the ordinates.*/\n        var y1 = calcSub[T0 - 1], y2 = calcSub[T0], y3 = calcSub[T0 + 1];\n        var a = (y1 + y3 - 2 * y2) / 2;\n        var b = (y3 - y1) / 2;\n        if (a)\n            T0 = T0 - b / (2 * a);\n        return sampleRate / T0;\n    };\n}\nexports.ACF2PLUS = ACF2PLUS;\n", "\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar MAX_FLWT_LEVELS = 6;\nvar MAX_F = 3000;\nvar DIFFERENCE_LEVELS_N = 3;\nvar MAXIMA_THRESHOLD_RATIO = 0.75;\nvar DEFAULT_DYNAMIC_WAVELET_CONFIG = {\n    sampleRate: 44100,\n};\nfunction DynamicWavelet(params) {\n    if (params === void 0) { params = {}; }\n    var config = __assign(__assign({}, DEFAULT_DYNAMIC_WAVELET_CONFIG), params);\n    var sampleRate = config.sampleRate;\n    return function DynamicWaveletDetector(float32AudioBuffer) {\n        var mins = [];\n        var maxs = [];\n        var bufferLength = float32AudioBuffer.length;\n        var freq = null;\n        var theDC = 0;\n        var minValue = 0;\n        var maxValue = 0;\n        // Compute max amplitude, amplitude threshold, and the DC.\n        for (var i = 0; i < bufferLength; i++) {\n            var sample = float32AudioBuffer[i];\n            theDC = theDC + sample;\n            maxValue = Math.max(maxValue, sample);\n            minValue = Math.min(minValue, sample);\n        }\n        theDC /= bufferLength;\n        minValue -= theDC;\n        maxValue -= theDC;\n        var amplitudeMax = maxValue > -1 * minValue ? maxValue : -1 * minValue;\n        var amplitudeThreshold = amplitudeMax * MAXIMA_THRESHOLD_RATIO;\n        // levels, start without downsampling...\n        var curLevel = 0;\n        var curModeDistance = -1;\n        var curSamNb = float32AudioBuffer.length;\n        var delta, nbMaxs, nbMins;\n        // Search:\n        while (true) {\n            delta = ~~(sampleRate / (Math.pow(2, curLevel) * MAX_F));\n            if (curSamNb < 2)\n                break;\n            var dv = void 0;\n            var previousDV = -1000;\n            var lastMinIndex = -1000000;\n            var lastMaxIndex = -1000000;\n            var findMax = false;\n            var findMin = false;\n            nbMins = 0;\n            nbMaxs = 0;\n            for (var i = 2; i < curSamNb; i++) {\n                var si = float32AudioBuffer[i] - theDC;\n                var si1 = float32AudioBuffer[i - 1] - theDC;\n                if (si1 <= 0 && si > 0)\n                    findMax = true;\n                if (si1 >= 0 && si < 0)\n                    findMin = true;\n                // min or max ?\n                dv = si - si1;\n                if (previousDV > -1000) {\n                    if (findMin && previousDV < 0 && dv >= 0) {\n                        // minimum\n                        if (Math.abs(si) >= amplitudeThreshold) {\n                            if (i > lastMinIndex + delta) {\n                                mins[nbMins++] = i;\n                                lastMinIndex = i;\n                                findMin = false;\n                            }\n                        }\n                    }\n                    if (findMax && previousDV > 0 && dv <= 0) {\n                        // maximum\n                        if (Math.abs(si) >= amplitudeThreshold) {\n                            if (i > lastMaxIndex + delta) {\n                                maxs[nbMaxs++] = i;\n                                lastMaxIndex = i;\n                                findMax = false;\n                            }\n                        }\n                    }\n                }\n                previousDV = dv;\n            }\n            if (nbMins === 0 && nbMaxs === 0) {\n                // No best distance found!\n                break;\n            }\n            var d = void 0;\n            var distances = [];\n            for (var i = 0; i < curSamNb; i++) {\n                distances[i] = 0;\n            }\n            for (var i = 0; i < nbMins; i++) {\n                for (var j = 1; j < DIFFERENCE_LEVELS_N; j++) {\n                    if (i + j < nbMins) {\n                        d = Math.abs(mins[i] - mins[i + j]);\n                        distances[d] += 1;\n                    }\n                }\n            }\n            var bestDistance = -1;\n            var bestValue = -1;\n            for (var i = 0; i < curSamNb; i++) {\n                var summed = 0;\n                for (var j = -1 * delta; j <= delta; j++) {\n                    if (i + j >= 0 && i + j < curSamNb) {\n                        summed += distances[i + j];\n                    }\n                }\n                if (summed === bestValue) {\n                    if (i === 2 * bestDistance) {\n                        bestDistance = i;\n                    }\n                }\n                else if (summed > bestValue) {\n                    bestValue = summed;\n                    bestDistance = i;\n                }\n            }\n            // averaging\n            var distAvg = 0;\n            var nbDists = 0;\n            for (var j = -delta; j <= delta; j++) {\n                if (bestDistance + j >= 0 && bestDistance + j < bufferLength) {\n                    var nbDist = distances[bestDistance + j];\n                    if (nbDist > 0) {\n                        nbDists += nbDist;\n                        distAvg += (bestDistance + j) * nbDist;\n                    }\n                }\n            }\n            // This is our mode distance.\n            distAvg /= nbDists;\n            // Continue the levels?\n            if (curModeDistance > -1) {\n                if (Math.abs(distAvg * 2 - curModeDistance) <= 2 * delta) {\n                    // two consecutive similar mode distances : ok !\n                    freq = sampleRate / (Math.pow(2, curLevel - 1) * curModeDistance);\n                    break;\n                }\n            }\n            // not similar, continue next level;\n            curModeDistance = distAvg;\n            curLevel++;\n            if (curLevel >= MAX_FLWT_LEVELS || curSamNb < 2) {\n                break;\n            }\n            //do not modify original audio buffer, make a copy buffer, if\n            //downsampling is needed (only once).\n            var newFloat32AudioBuffer = float32AudioBuffer.subarray(0);\n            if (curSamNb === distances.length) {\n                newFloat32AudioBuffer = new Float32Array(curSamNb / 2);\n            }\n            for (var i = 0; i < curSamNb / 2; i++) {\n                newFloat32AudioBuffer[i] =\n                    (float32AudioBuffer[2 * i] + float32AudioBuffer[2 * i + 1]) / 2;\n            }\n            float32AudioBuffer = newFloat32AudioBuffer;\n            curSamNb /= 2;\n        }\n        return freq;\n    };\n}\nexports.DynamicWavelet = DynamicWavelet;\n", "\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DEFAULT_MACLEOD_PARAMS = {\n    bufferSize: 1024,\n    cutoff: 0.97,\n    sampleRate: 44100,\n};\nfunction Macleod(params) {\n    if (params === void 0) { params = {}; }\n    var config = __assign(__assign({}, DEFAULT_MACLEOD_PARAMS), params);\n    var bufferSize = config.bufferSize, cutoff = config.cutoff, sampleRate = config.sampleRate;\n    /**\n     * For performance reasons, peaks below this cutoff are not even considered.\n     */\n    var SMALL_CUTOFF = 0.5;\n    /**\n     * Pitch annotations below this threshold are considered invalid, they are\n     * ignored.\n     */\n    var LOWER_PITCH_CUTOFF = 80;\n    /**\n     * Contains a normalized square difference function value for each delay\n     * (tau).\n     */\n    var nsdf = new Float32Array(bufferSize);\n    /**\n     * Contains a sum of squares of the Buffer, for improving performance\n     * (avoids redoing math in the normalized square difference function)\n     */\n    var squaredBufferSum = new Float32Array(bufferSize);\n    /**\n     * The x and y coordinate of the top of the curve (nsdf).\n     */\n    var turningPointX;\n    var turningPointY;\n    /**\n     * A list with minimum and maximum values of the nsdf curve.\n     */\n    var maxPositions = [];\n    /**\n     * A list of estimates of the period of the signal (in samples).\n     */\n    var periodEstimates = [];\n    /**\n     * A list of estimates of the amplitudes corresponding with the period\n     * estimates.\n     */\n    var ampEstimates = [];\n    /**\n     * Implements the normalized square difference function. See section 4 (and\n     * the explanation before) in the MPM article. This calculation can be\n     * optimized by using an FFT. The results should remain the same.\n     */\n    function normalizedSquareDifference(float32AudioBuffer) {\n        var acf;\n        var divisorM;\n        squaredBufferSum[0] = float32AudioBuffer[0] * float32AudioBuffer[0];\n        for (var i = 1; i < float32AudioBuffer.length; i += 1) {\n            squaredBufferSum[i] =\n                float32AudioBuffer[i] * float32AudioBuffer[i] + squaredBufferSum[i - 1];\n        }\n        for (var tau = 0; tau < float32AudioBuffer.length; tau++) {\n            acf = 0;\n            divisorM =\n                squaredBufferSum[float32AudioBuffer.length - 1 - tau] +\n                    squaredBufferSum[float32AudioBuffer.length - 1] -\n                    squaredBufferSum[tau];\n            for (var i = 0; i < float32AudioBuffer.length - tau; i++) {\n                acf += float32AudioBuffer[i] * float32AudioBuffer[i + tau];\n            }\n            nsdf[tau] = (2 * acf) / divisorM;\n        }\n    }\n    /**\n     * Finds the x value corresponding with the peak of a parabola.\n     * Interpolates between three consecutive points centered on tau.\n     */\n    function parabolicInterpolation(tau) {\n        var nsdfa = nsdf[tau - 1], nsdfb = nsdf[tau], nsdfc = nsdf[tau + 1], bValue = tau, bottom = nsdfc + nsdfa - 2 * nsdfb;\n        if (bottom === 0) {\n            turningPointX = bValue;\n            turningPointY = nsdfb;\n        }\n        else {\n            var delta = nsdfa - nsdfc;\n            turningPointX = bValue + delta / (2 * bottom);\n            turningPointY = nsdfb - (delta * delta) / (8 * bottom);\n        }\n    }\n    // Finds the highest value between each pair of positive zero crossings.\n    function peakPicking() {\n        var pos = 0;\n        var curMaxPos = 0;\n        // find the first negative zero crossing.\n        while (pos < (nsdf.length - 1) / 3 && nsdf[pos] > 0) {\n            pos++;\n        }\n        // loop over all the values below zero.\n        while (pos < nsdf.length - 1 && nsdf[pos] <= 0) {\n            pos++;\n        }\n        // can happen if output[0] is NAN\n        if (pos == 0) {\n            pos = 1;\n        }\n        while (pos < nsdf.length - 1) {\n            if (nsdf[pos] > nsdf[pos - 1] && nsdf[pos] >= nsdf[pos + 1]) {\n                if (curMaxPos == 0) {\n                    // the first max (between zero crossings)\n                    curMaxPos = pos;\n                }\n                else if (nsdf[pos] > nsdf[curMaxPos]) {\n                    // a higher max (between the zero crossings)\n                    curMaxPos = pos;\n                }\n            }\n            pos++;\n            // a negative zero crossing\n            if (pos < nsdf.length - 1 && nsdf[pos] <= 0) {\n                // if there was a maximum add it to the list of maxima\n                if (curMaxPos > 0) {\n                    maxPositions.push(curMaxPos);\n                    curMaxPos = 0; // clear the maximum position, so we start\n                    // looking for a new ones\n                }\n                while (pos < nsdf.length - 1 && nsdf[pos] <= 0) {\n                    pos++; // loop over all the values below zero\n                }\n            }\n        }\n        if (curMaxPos > 0) {\n            maxPositions.push(curMaxPos);\n        }\n    }\n    return function Macleod(float32AudioBuffer) {\n        // 0. Clear old results.\n        var pitch;\n        maxPositions = [];\n        periodEstimates = [];\n        ampEstimates = [];\n        // 1. Calculute the normalized square difference for each Tau value.\n        normalizedSquareDifference(float32AudioBuffer);\n        // 2. Peak picking time: time to pick some peaks.\n        peakPicking();\n        var highestAmplitude = -Infinity;\n        for (var i = 0; i < maxPositions.length; i++) {\n            var tau = maxPositions[i];\n            // make sure every annotation has a probability attached\n            highestAmplitude = Math.max(highestAmplitude, nsdf[tau]);\n            if (nsdf[tau] > SMALL_CUTOFF) {\n                // calculates turningPointX and Y\n                parabolicInterpolation(tau);\n                // store the turning points\n                ampEstimates.push(turningPointY);\n                periodEstimates.push(turningPointX);\n                // remember the highest amplitude\n                highestAmplitude = Math.max(highestAmplitude, turningPointY);\n            }\n        }\n        if (periodEstimates.length) {\n            // use the overall maximum to calculate a cutoff.\n            // The cutoff value is based on the highest value and a relative\n            // threshold.\n            var actualCutoff = cutoff * highestAmplitude;\n            var periodIndex = 0;\n            for (var i = 0; i < ampEstimates.length; i++) {\n                if (ampEstimates[i] >= actualCutoff) {\n                    periodIndex = i;\n                    break;\n                }\n            }\n            var period = periodEstimates[periodIndex], pitchEstimate = sampleRate / period;\n            if (pitchEstimate > LOWER_PITCH_CUTOFF) {\n                pitch = pitchEstimate;\n            }\n            else {\n                pitch = -1;\n            }\n        }\n        else {\n            // no pitch detected.\n            pitch = -1;\n        }\n        return {\n            probability: highestAmplitude,\n            freq: pitch,\n        };\n    };\n}\nexports.Macleod = Macleod;\n", "\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DEFAULT_FREQUENCIES_PARAMS = {\n    tempo: 120,\n    quantization: 4,\n    sampleRate: 44100,\n};\nfunction pitchConsensus(detectors, chunk) {\n    var pitches = detectors\n        .map(function (fn) { return fn(chunk); })\n        .filter(function (value) { return value !== null; })\n        .sort(function (a, b) { return a - b; });\n    // In the case of one pitch, return it.\n    if (pitches.length === 1) {\n        return pitches[0];\n        // In the case of two pitches, return the geometric mean if they\n        // are close to each other, and the lower pitch otherwise.\n    }\n    else if (pitches.length === 2) {\n        var first = pitches[0], second = pitches[1];\n        return first * 2 > second ? Math.sqrt(first * second) : first;\n        // In the case of three or more pitches, filter away the extremes\n        // if they are very extreme, then take the geometric mean.\n    }\n    else {\n        var first = pitches[0];\n        var second = pitches[1];\n        var secondToLast = pitches[pitches.length - 2];\n        var last = pitches[pitches.length - 1];\n        var filtered1 = first * 2 > second ? pitches : pitches.slice(1);\n        var filtered2 = secondToLast * 2 > last ? filtered1 : filtered1.slice(0, -1);\n        return Math.pow(filtered2.reduce(function (t, p) { return t * p; }, 1), 1 / filtered2.length);\n    }\n}\nfunction frequencies(detector, float32AudioBuffer, options) {\n    if (options === void 0) { options = {}; }\n    var config = __assign(__assign({}, exports.DEFAULT_FREQUENCIES_PARAMS), options);\n    var tempo = config.tempo, quantization = config.quantization, sampleRate = config.sampleRate;\n    var bufferLength = float32AudioBuffer.length;\n    var chunkSize = Math.round((sampleRate * 60) / (quantization * tempo));\n    var getPitch;\n    if (Array.isArray(detector)) {\n        getPitch = pitchConsensus.bind(null, detector);\n    }\n    else {\n        getPitch = detector;\n    }\n    var pitches = [];\n    for (var i = 0, max = bufferLength - chunkSize; i <= max; i += chunkSize) {\n        var chunk = float32AudioBuffer.slice(i, i + chunkSize);\n        var pitch = getPitch(chunk);\n        pitches.push(pitch);\n    }\n    return pitches;\n}\nexports.frequencies = frequencies;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar yin_1 = require(\"./detectors/yin\");\nexports.YIN = yin_1.YIN;\nvar amdf_1 = require(\"./detectors/amdf\");\nexports.AMDF = amdf_1.AMDF;\nvar acf2plus_1 = require(\"./detectors/acf2plus\");\nexports.ACF2PLUS = acf2plus_1.ACF2PLUS;\nvar dynamic_wavelet_1 = require(\"./detectors/dynamic_wavelet\");\nexports.DynamicWavelet = dynamic_wavelet_1.DynamicWavelet;\nvar macleod_1 = require(\"./detectors/macleod\");\nexports.Macleod = macleod_1.Macleod;\nvar frequencies_1 = require(\"./tools/frequencies\");\nexports.frequencies = frequencies_1.frequencies;\nexports.default = {\n    YIN: yin_1.YIN,\n    AMDF: amdf_1.AMDF,\n    ACF2PLUS: acf2plus_1.ACF2PLUS,\n    DynamicWavelet: dynamic_wavelet_1.DynamicWavelet,\n    Macleod: macleod_1.Macleod,\n    frequencies: frequencies_1.frequencies,\n};\n"],
  "mappings": "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",
  "names": ["Macleod"]
}
