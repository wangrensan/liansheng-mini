"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var MAX_FLWT_LEVELS = 6;
var MAX_F = 3000;
var DIFFERENCE_LEVELS_N = 3;
var MAXIMA_THRESHOLD_RATIO = 0.75;
var DEFAULT_DYNAMIC_WAVELET_CONFIG = {
    sampleRate: 44100,
};
function DynamicWavelet(params) {
    if (params === void 0) { params = {}; }
    var config = __assign(__assign({}, DEFAULT_DYNAMIC_WAVELET_CONFIG), params);
    var sampleRate = config.sampleRate;
    return function DynamicWaveletDetector(float32AudioBuffer) {
        var mins = [];
        var maxs = [];
        var bufferLength = float32AudioBuffer.length;
        var freq = null;
        var theDC = 0;
        var minValue = 0;
        var maxValue = 0;
        // Compute max amplitude, amplitude threshold, and the DC.
        for (var i = 0; i < bufferLength; i++) {
            var sample = float32AudioBuffer[i];
            theDC = theDC + sample;
            maxValue = Math.max(maxValue, sample);
            minValue = Math.min(minValue, sample);
        }
        theDC /= bufferLength;
        minValue -= theDC;
        maxValue -= theDC;
        var amplitudeMax = maxValue > -1 * minValue ? maxValue : -1 * minValue;
        var amplitudeThreshold = amplitudeMax * MAXIMA_THRESHOLD_RATIO;
        // levels, start without downsampling...
        var curLevel = 0;
        var curModeDistance = -1;
        var curSamNb = float32AudioBuffer.length;
        var delta, nbMaxs, nbMins;
        // Search:
        while (true) {
            delta = ~~(sampleRate / (Math.pow(2, curLevel) * MAX_F));
            if (curSamNb < 2)
                break;
            var dv = void 0;
            var previousDV = -1000;
            var lastMinIndex = -1000000;
            var lastMaxIndex = -1000000;
            var findMax = false;
            var findMin = false;
            nbMins = 0;
            nbMaxs = 0;
            for (var i = 2; i < curSamNb; i++) {
                var si = float32AudioBuffer[i] - theDC;
                var si1 = float32AudioBuffer[i - 1] - theDC;
                if (si1 <= 0 && si > 0)
                    findMax = true;
                if (si1 >= 0 && si < 0)
                    findMin = true;
                // min or max ?
                dv = si - si1;
                if (previousDV > -1000) {
                    if (findMin && previousDV < 0 && dv >= 0) {
                        // minimum
                        if (Math.abs(si) >= amplitudeThreshold) {
                            if (i > lastMinIndex + delta) {
                                mins[nbMins++] = i;
                                lastMinIndex = i;
                                findMin = false;
                            }
                        }
                    }
                    if (findMax && previousDV > 0 && dv <= 0) {
                        // maximum
                        if (Math.abs(si) >= amplitudeThreshold) {
                            if (i > lastMaxIndex + delta) {
                                maxs[nbMaxs++] = i;
                                lastMaxIndex = i;
                                findMax = false;
                            }
                        }
                    }
                }
                previousDV = dv;
            }
            if (nbMins === 0 && nbMaxs === 0) {
                // No best distance found!
                break;
            }
            var d = void 0;
            var distances = [];
            for (var i = 0; i < curSamNb; i++) {
                distances[i] = 0;
            }
            for (var i = 0; i < nbMins; i++) {
                for (var j = 1; j < DIFFERENCE_LEVELS_N; j++) {
                    if (i + j < nbMins) {
                        d = Math.abs(mins[i] - mins[i + j]);
                        distances[d] += 1;
                    }
                }
            }
            var bestDistance = -1;
            var bestValue = -1;
            for (var i = 0; i < curSamNb; i++) {
                var summed = 0;
                for (var j = -1 * delta; j <= delta; j++) {
                    if (i + j >= 0 && i + j < curSamNb) {
                        summed += distances[i + j];
                    }
                }
                if (summed === bestValue) {
                    if (i === 2 * bestDistance) {
                        bestDistance = i;
                    }
                }
                else if (summed > bestValue) {
                    bestValue = summed;
                    bestDistance = i;
                }
            }
            // averaging
            var distAvg = 0;
            var nbDists = 0;
            for (var j = -delta; j <= delta; j++) {
                if (bestDistance + j >= 0 && bestDistance + j < bufferLength) {
                    var nbDist = distances[bestDistance + j];
                    if (nbDist > 0) {
                        nbDists += nbDist;
                        distAvg += (bestDistance + j) * nbDist;
                    }
                }
            }
            // This is our mode distance.
            distAvg /= nbDists;
            // Continue the levels?
            if (curModeDistance > -1) {
                if (Math.abs(distAvg * 2 - curModeDistance) <= 2 * delta) {
                    // two consecutive similar mode distances : ok !
                    freq = sampleRate / (Math.pow(2, curLevel - 1) * curModeDistance);
                    break;
                }
            }
            // not similar, continue next level;
            curModeDistance = distAvg;
            curLevel++;
            if (curLevel >= MAX_FLWT_LEVELS || curSamNb < 2) {
                break;
            }
            //do not modify original audio buffer, make a copy buffer, if
            //downsampling is needed (only once).
            var newFloat32AudioBuffer = float32AudioBuffer.subarray(0);
            if (curSamNb === distances.length) {
                newFloat32AudioBuffer = new Float32Array(curSamNb / 2);
            }
            for (var i = 0; i < curSamNb / 2; i++) {
                newFloat32AudioBuffer[i] =
                    (float32AudioBuffer[2 * i] + float32AudioBuffer[2 * i + 1]) / 2;
            }
            float32AudioBuffer = newFloat32AudioBuffer;
            curSamNb /= 2;
        }
        return freq;
    };
}
exports.DynamicWavelet = DynamicWavelet;
